---
title: CS50p Notes by Unit
format: html
theme: solar
toc: true
toc-location: left
toc-expand: true
fontcolor: "#ECEFF1"
# Still want to change/configure the background color for the callout boxes
code-copy: hover
code-line-numbers: true
code-block-bg: "#37474F"
---
# Document Introduction {#sec-introduction .unnumbered}
## Git {#sec-git .unnumbered}
- My local Computer_Science repo now has a specific branch for CS50p
  - Note, you can use git within the .venv or outside of it, git is unaffected by the virtual environment for CS50p.
```{zsh}
git checkout cs50p
git add .
git commit -m "Saving recent work for CS50p."
git checkout main
git merge --no-ff cs50p main
git push
```

## Quarto and Markdown {#sec-quarto-markdown .unnumbered}
- Quarto is used from the command line, the .qmd file uses markdown syntax
- Using Docker to spin up a container to run the quarto preview was clunky and complicated, still did not work
  - So, simplest solution is spinning up a virtual envionment in the folder I want to work from and then using the venv

### Some general markdown tips for .qmd files {#sec-md-tips .unnumbered}
- Even though there are general settings set at the top of the `.qmd` file, when settings are changed on specific objects, *all* of their settings must be configured, even the document's defaults

:::{#nte-quarto_md_basics .callout-note .unnumbered}
## Quarto Markdown Basics

For more markdown tips, docs, and shortcuts <https://quarto.org/docs/authoring/markdown-basics.html>
:::

# Unit 0: Functions and Variables {#sec-unit_0 .unnumbered}
## Lecture 0 {#sec-lecture_0}
### Integers or `int` {#sec-integers}
- F-string formatting is a way to embed variables in strings, simply use ```print(f"There are, {count} apples.")```
- In python an integer is referred to as an `int` 
- It's easy to interact with `int` variables natively in Python
```{python}
#| echo: true
x = 1
y = 2

z = x + y

print(z)
```
- You can improve upon the above program by using base Python functions
```{python}
x = 5#int(input("What's x? "))
y = 4#int(input("What's y? "))

print(x + y)
```
::: {#nte-hardcoded_variables .callout-note}
## Hardcoded Variable Values

Quarto does not support user input code rendering, so the file preview fails with functions like `input()`. As a result, appropriate values are hard-coded.
:::

### Floats {#sec-floats}
- A floating point value is a real number with a decimal, like `0.52`
- Modifying the previous code to use the `float` data type allows you to perform operations on decimals too
- When dealing with decimals, you may want or need to round the values
- You can tie everything together with the following code, which rounds the sum to 2 decimal places
  - Additionally, ```print(f"{z:,}")``` prints the variable `z` and adds a comma to the value
```{python}
# Get the user's input
x = 2#float(input("What's x? "))
y = 3.3#float(input("What's y? "))

# Create a rounded result
z = round(x + y, 2)

# Print the formatted result
print(f"{z:,}")
```
- Finally, you could remove the piece of code that rounds the values with f-string formatting
```{python}
# Get the user's input
x = 2.2#float(input("What's x? "))
y = 3.4#float(input("What's y? "))

# Calculate the result
z = x / y

# Print the result
print(f"{z:.2f}")
```

::: {#nte-numeric_operators .callout-note}
## Python Numeric Operators

Python has several built-in operators for numeric data types: `+`, `-`, `*`, `/`, `** (exponentiation)`, `% (remainder)`.
:::

### Def (User Defined Functions) {#sec-udf}
* Use the `def` keyword to initialize a UDF (user-defined function)
* Follow this with the function name, parentheses, and then any conditions in the parentheses
```{python}
def hello():
    print("hello")


name = "Chris"#input("What's your name? ")
hello()
print(name)
```
- Notice how everything is indented under def, Python uses indentation to understand what's part of the function
- Similar to other programming languages, Python utilizes main functions in scripts for the primary purpose
- Utilize a main function and return a value as follows
```{python}
def main():
    x = 3#int(input("What's x? "))
    print("x squared is", square(x))


def square(n):
    return n * n


main()
```

## Problem Set 0 {#sec-problem-set-0}
```{python}
#| lst-label: lst-0_indoor
#| lst-cap: Indoor Voice
#| code-line-numbers: true

# Problem Set 0, Problem 1
# Prompt the user for input
def ask_user():
    global a
    a = "MY NAME IS WD-40"
    return a

# Lowercase the string


def a_lower():
    print(a.lower())


ask_user()
a_lower()

```
```{python}
#| lst-label: lst-0_playback
#| lst-cap: Playback Speed
#| code-line-numbers: true

# Prompt the user for input
def ask_user():
    global a
    a = "Hello, it's very nice to meet you!"
    return a

# Add the three periods


def playback():
    b = a.replace(' ', '...')
    print(b)


ask_user()
playback()
```
```{python}
#| lst-label: lst-0_faces
#| lst-cap: Making Faces
#| code-line-numbers: true

# Build main function
def main():
    # Prompt the user for a value
    a = ":)"

    # Conver the input
    b = convert(a)

    return print(b)

# Build the convert function
def convert(val):
    # Replace the slightly smiling and slightly frowning faces in place and overwrite the input variable
    val = str(val).replace(":)", "\U0001F642").replace(":(", "\U0001f641")

    return val


main()
```
```{python}
#| lst-label: lst-0_einstein
#| lst-cap: Einstein
#| code-line-numbers: true

def main():
    # Prompt the user for an integer
    m = int(50)

    # Store the speed of light
    c = 300000000

    # Calculate the energy
    e = m * (c ** 2)

    return print(f"E: {e}")

main()
```
```{python}
#| lst-label: lst-0_tip
#| lst-cap: Tip Calculator
#| code-line-numbers: true

def main():
    meal = dollars_to_float("76.50")
    percent = percent_to_float("20%")
    tip = meal * percent
    print(f"Leave ${tip:.2f}")


def dollars_to_float(d):
    # Should accept a str as input in excepted format of $##.## and remove the leading $
    d = d.replace("$", "")
    # Convert d to a float
    d = float(d)

    return d


def percent_to_float(p):
    # Should accept a str as input in expected format of ##% and remove the trailing %
    p = p.replace("%", "")
    # Return p as a percentage, stored as a decimal float
    p = float(p) * 0.01

    return p


main()
```
# Unit 1: Conditionals {#sec-unit_1}
## Lecture 1 {#sec-lecture_1}
- Conditionals allow you to provide specific instructions in your program on how to handle various situations
- Python has a set of built-in operators to compare a left hand term to a right hand term
  - `> and <` are what you expect: greater than and less than, respectively. 
  - `>= and <=` follow the same pattern as above: greater than or equal to and less than or equal to, respectively.
  - `== and !=` this denotes equal to and not equal to, respectively.

::: {#nte-equal_sign_diff .callout-note}
## Difference betweeen `=` and `==`

Using a single `=` will assign a value on the right to the value on the left: `x = 2`; however, the double `==` will check if the value on the right equals the value on the left `x == 2`.  
:::

### if Statements {#sec-if}
- `if` Statements use `bool` or boolean values (`true or false`) to decide whether to execute
- To better understand if statement behavior look at the following code:
```{python}
x = 5
y = 4

if x < y:
    print("x is less than y")
if x > y:
    print("x is greater than y")
if x == y:
    print("x is equal to y")
```
- Python evaluates the first if statement and sees that 5 is not less than 4, so it does nothing
  - Then, Python evaluates the second if statement and see that 5 is greater than 4, so it prints the message
  - As a result, the program stops and the third statement is not evaluated (even though the third statement is not true anyways)
  - This "flow" of decisions is called **`control flow`**
- You can improve upon this flow using the `if` `elif` `else` syntax
```{python}
x = 5
y = 5

if x < y:
    print("x is less than y")
elif x > y:
    print("x is greater than y")
else:
    print("x is equal to y")
```

### or Statements {#sec-or}
- `or` allows your program to decide between one or more alternatives
- When dealing with multiple conditions, using *or* can drastically decrease code complexity
```{python}
x = 5
y = 7

if (x < y) or (x > y):
    print("x is not equal to y")
else:
    print("x is equal to y")
```
- This code block works, but we could improve upon it further by just checking to see if `x == y` or `x != y`

### and Statements {#sec-and}
- `and` statements are another type of conditional, they check whether something meets multiple conditions simultaneously 
- Starting with the following code, let's make some readability and functionality improvements
```{python}
score = 78
if score >= 90 and score <= 100:
    print("Grade: A")
elif score >= 80 and score < 90:
    print("Grade: B")
elif score >= 70 and score < 80:
    print("Grade: C")
elif score >= 60 and score < 70:
    print("Grade: D")
else:
    print("Grade: F")
```
- A nice feature of python is you can chain together conditionals in an easy to understand format
```{python}
score = 81
if 90 <= score <= 100:
    print("Grade: A")
elif 80 <= score < 90:
    print("Grade: B")
elif 70 <= score < 80:
    print("Grade: C")
elif 60 <= score < 70:
    print("Grade: D")
else:
    print("Grade: F")
```
- Again, similar to `or` it's best to ask the simplest question in a conditional
```{python}
score = 90
if score >= 90:
    print("Grade: A")
elif score >= 80:
    print("Grade: B")
elif score >= 70:
    print("Grade: C")
elif score >= 60:
    print("Grade: D")
else:
    print("Grade: F")
```

### Modulo {#sec-modulo}
- Mentioned briefly in [@nte-numeric_operators], the `%` operator shows whether a number divides evenly or with a remainder
  - For example, `24 % 2` evaluates to `0`, but `24 % 5` evaluates to 4 the *remainder*
  - In mathematics, whether something is even or odd is referred to as parity
- Discussed in [Unit @sec-udf] it's useful to create your own functions
```{python}
def main():
    x = 21
    if is_even(x):
        print("Even")
    else:
        print("Odd")

def is_even(n):
    if n % 2 == 0:
        return True
    else:
        return False

main()
```
- In programming, the phrase *Pythonic* refers to a way to code something that only occurs in Python
- You can further refine your code and abstract away some of the process using native Python functionality
- Simplify `is_even(n)` to the following
  - Recall that `==` evaluates whether something is equal or not, it returns a `Bool`
```{python}
def main():
    x = 94
    if is_even(x):
        print("Even")
    else:
        print("Odd")

def is_even(n):
    return n % 2 == 0

main()
```

### match Statements {#sec-match}
- Similar to other conditional statements, `match` can be used to run code that matches a certain value
- The structure follows the Python pattern of identation with conditions and uses the keywords `match` and `case`
```{python}
name = "Ron"

match name:
    case "Harry":
        print("Gryffindor")
    case "Ron":
        print("Gryffindor")
    case "Hermione":
        print("Gryffindor")
    case "Draco":
        print("Slytherin")
    case _:
        print("Who?")
```
- The `_` functions similar to an `else` statement as it takes in all values
- This statement compares the value following `match` with each value following `case`
  - In the event a match is found, the indented code is executed and the search *stops*
- Improve upon the code by using the `|` operator, which equates to `or` and checks multiple values in the same case statement
```{python}
name = "Hermione"

match name:
    case "Harry" | "Ron" | "Hermione":
        print("Gryffindor")
    case "Draco":
        print("Slytherin")
    case _:
        print("Who?")
```

## Problem Set 1 {#sec-problem_set_1}
```{python}
#| lst-label: lst-1_thought
#| lst-cap: Deep Thought
#| code-line-numbers: true

# Build the main function
def main():
    # Prompt the user for the answer to the Great Question of Life, the Universe and Everything
    ans = ("ForTy-tWo").lower().strip()

    match ans:
        case "42" | "forty-two" | "forty two":
            return print("Yes")
        case _:
            return print("No")


main()
```
:::{#tip-case_conditions .callout-tip}
## Case Conditions

The `case _ if` syntax allows you to add conditions to each case when using a match statement. Combine this with the `in` operator to perform searches in strings: `case _ if h in hello`. 
:::
```{python}
#| lst-label: lst-1_bank
#| lst-cap: Home Federal Savings Bank
#| code-line-numbers: true

# Build the main function
def main():
    # Prompt the user for a greeting
    greet = ("How you doing?").lower().strip()

    # Decide how much money the user gets
    match greet:
         case _ if greet.startswith("hello"):
              return print("$0")
         case _ if greet.startswith("h"):
              return print("$20")
         case _:
              return print("$100")


main()
```
```{python}
#| lst-label: lst-1_file
#| lst-cap: File Extensions
#| code-line-numbers: true

# Build the main function
def main():
    # Put the necessary extensions in a tuple
    ext = (".gif", ".jpg", ".jpeg", ".png", ".pdf", ".txt", ".zip")
    # Group those into MIME types
    mime = ("image/gif", "image/jpeg", "image/png", "application/pdf", "text/plain", "application/zip")
    # Get the user's file
    file = "virus.png".lower().strip()

    # Check which MIME type the file is and return the value
    if file.endswith(ext):
        if file.split('.')[-1] == ext[1].split('.')[-1] or file.split('.')[-1] == ext[2].split('.')[-1]:
            return print(mime[1])
        elif file.split('.')[-1] == ext[0].split('.')[-1]:
            return print(mime[0])
        elif file.split('.')[-1] == ext[3].split('.')[-1]:
            return print(mime[2])
        elif file.split('.')[-1] == ext[4].split('.')[-1]:
            return print(mime[3])
        elif file.split('.')[-1] == ext[-2].split('.')[-1]:
            return print(mime[-2])
        else:
            return print(mime[-1])
    else:
        return print("application/octet-stream")


main()
```
:::{#nte-repetitive_code .callout-note}
There are far more efficient ways to do the above, including using a dictionary and iterators. Those are covered in the next unit.
:::
```{python}
#| lst-label: lst-1_math
#| lst-cap: Math Interpreter
#| code-line-numbers: true

# Build the main function
def main():
    # Prompt the user for an expression
    exp = "52 / 6"

    # Split the expression into x, y, and z
    x, y, z = exp.split(' ')

    # Ensure Data Quality
    x = float(x)
    z = float(z)

    # Evaluate the expression
    match y:
        case _ if y == '+':
            return print(x + z)
        case _ if y == '-':
            return print(x - z)
        case _ if y == '*':
            return print(x * z)
        case _ if y == '/':
            return print(x / z)
        case _:
            return 0


main()
```
```{python}
#| lst-label: lst-1_meal
#| lst-cap: Meal Time
#| code-line-numbers: true

# Build the main function
def main():
    # Prompt the user for the time
    ut = "7:03"

    # Convert the time to a float
    tm = convert(ut)

    # Return what meal corresponds to the time, if any
    match tm:
        case _ if 7.00 <= tm <= 8.00:
            return print("breakfast time")
        case _ if 12.00 <= tm <= 13.00:
            return print("lunch time")
        case _ if 18.00 <= tm <= 19.00:
            return print("dinner time")
        case _:
            return exit

def convert(time):
    # Convert the string via code that performs several operations at once
    # The string time is split at the ':', the first item is converted to float
    # The Second item is converted to float and then divided by 60 to convert it to a decimal
    time = float(time.split(":")[0]) + float(time.split(":")[1])/60

    return time



if __name__ == '__main__':
    main()
```

# Unit 2: Loops {#sec-unit_2}
## Lecture 2 {#sec-lecture_2}
- Loops are a way of doing something over and over again
- Pretend you write the following block of code
```{python}
#| output: false

print("meow")
print("meow")
print("meow")
```
- It's not going to be efficient to do this 20 times, let a few hundred, this is where loops are useful

### while Loops {#sec-while_loops}
- The `while` loops is nearly universal in all coding languages
- As its name says, it runs while a condition is `true` and until it is `false` or *vice versa*
  - Like with all processes run from a command line, use `Ctrl-C` to kill any hanging or infinitely running programs
- The term iteration is very significant with regards to coding, it refers to each cycle through a loop
- For a basic example of a while loop with an iteration counter:
```{python}
i = 0
while i < 3:
    print("meow")
    i += 1
```

:::{#tip-add_sub_assignment .callout-tip}
## Addition and Subtraction Assignment Operators
The `+=` and `-=` symbols are the addition and subtraction assignment operators, respectively. They are a great shortcut for iteratively adding values while looping. 
:::

### for Loops {#sec-for_loops}
- A `for` loop is used with what's called an `iterable` data type, like a `list` or `dictionary`
  - This is a crucial component of problem solving with Python, there will be several code examples to illustrate how it works
  - Using the same example as the while loop, look how clean the following is
``` {python}
#| output: false

for i in [0, 1, 2]:
    print("meow")
``` 
- This can be further improved upon using the `range` data type, and the built-in `range()` function
```{python}
#| output: false

for i in range(3):
    print("meow")
```

:::{#nte-underscore_wildcard .callout-note}
## Use of the `_` as a wildcard operator
You can further simplifying things by removing the unused `i` and replacing it with a `_` to represent it. ***However,*** only do this when the variable you're replacing, in this case `i`, isn't used in the code.
:::

```{python}
#| output: false

for _ in range(3):
    print("meow")
```
- Finally, you could write this out on one line, without the use of a loop (just as an example)
  - Adding the `\n` linebreak and `end=""` tells the compiler to add a linebreak at the end of each meow
```{python}
#| output: false

print("meow\n" * 3, end="")
```
- You can bring out more of loops by combining their functionality
  - It's common to use `while` to validate user input
  - The keywords `continue` and `break` tell a loop to go to the next iteration of a loop or break out, respectively
  - See how you can tie together various kinds of loops with the following 
```{python}
#| output: false

def main():
    meow(get_number())


def get_number():
    while True:
        n = int("5")
        if n > 0:
            return n


def meow(n):
    for _ in range(n):
        print("meow")


main()
```

### Iterables {#sec-iterables}
- Python uses what's called `zero indexing`, meaning object position indexes start at 0
- For iterables, like a `list`, `dict`, or `range` this is important when performing positional transformations
- Another useful function when talking about objects is `len`
  - For iterable data types, this will provide the *length* of an object
  - Combine this function with previous examples to simplify your code
```{python}
students = ["Harry", "Ron", "Hermione"]

for i in range(len(students)):
    print(i + 1, students[i])
```
- `Dictionaries` are another core iterable type in Python, with numerous applications across specializations
  - Software Development
  - Data Engineering
  - Machine Learning
  - etc.
- While a list stores multiple values or objects (even other lists), a dictionary stores a key and values
- You could store students and houses in lists and try to keep their positions always lined up, but the issues are obvious
- A better approach is using a dictionary
```{python}
#| output: false

students_list = ["Hermoine", "Harry", "Ron", "Draco"]
houses_list = ["Gryffindor", "Gryffindor", "Griffindor", "Slytherin"]

students = {
    "Hermoine": "Gryffindor",
    "Harry": "Gryffindor",
    "Ron": "Gryffindor",
    "Draco": "Slytherin",
}
for student in students:
    print(student, students[student], sep=", ")
```
- You could also expand your dictionary to have more information than just the Student and their House
```{python}
#| output: false

students = [
    {"name": "Hermoine", "house": "Gryffindor", "patronus": "Otter"},
    {"name": "Harry", "house": "Gryffindor", "patronus": "Stag"},
    {"name": "Ron", "house": "Gryffindor", "patronus": "Jack Russell terrier"},
    {"name": "Draco", "house": "Slytherin", "patronus": None},
]

for student in students:
    print(student["name"], student["house"], student["patronus"], sep=", ")
```

### Mario {#sec-mario}
- The classic 2D Mario games are a great illustration of the use of loops
  - Similar to `meow` imagine printing three `#` in a vertical stack, just like blocks in Mario
  - You could do it one line of code at a time, or with a for loop
- You can easily modify the below code to print block width instead
- ```print("#" * n)``` instead of a loop will print the character n times on a line
```{python}
#| output: false

# Build main function
def main():
    return block_height(3)

def block_height(n):
    for _ in range(n):
        print("#")

main()
```
- You can combine code for the height, with code for the width to print out a square
  - Doing so, you'll see how nested for loops behave
  - Notice the use of `end=""` which changes the default line end behavior of print from a line break `"\n"` to continuing on the same line
```{python}
# Build main function
def main():
    # Get the height
    blocks = int(3)

    # Print the square
    for h in range(blocks):
        # Print the columns
        for w in range(blocks):
            print("#", end = "")
        # Print the rows
        print()

# Build the row function
def print_row(n):
    print("#" * n)

# Build the column function
def print_col(h):
    for _ in range(h):
        print("#")

main()
```

## Problem Set 2 {#sec-problem_set_2}
:::{#nte-camel_snake_case .callout-note}
## camelCase and snake_case
Many times in code, you'll see variable names in various formats. Most commonly, you'll see `camelCase`, where the first word is lower case and then subsequent words have a capital first letter without a space separator, and `snake_case` where all words are lower case and they're separated by an `_`. 
:::
```{python}
#| lst-label: lst-2_camel
#| lst-cap: camelCase
#| code-line-numbers: true

# Build the main function
def main():
    # Prompt the user for a variable in camelCase
    camel = "testThisProgramOutForMe".strip()

    # Convert the variable name to snake_case, first initialize a blank list
    snake = []
    # Iterate through the variable string
    # By adding a print() line in each iteration, I can check to see where code breaks
    start = 1
    for a in camel:
        # Start the snake list with the first letter in the camelCase variable
        # Data quality check: with the binary start variable, if the first letter in the first word is the same as the last, like in test
        # I am able to avoid any bugs/errors
        if a == camel[0] and start == 1:
            snake = snake + list(a)
            # print(snake)
            start -= 1
        # If lowercase, add it to the most recent list item
        elif a.islower():
            snake[-1] = snake[-1] + a
            # print(snake)
        # If uppercase, add a new list item
        elif a.isupper():
            snake = snake + list(a)
            # print(snake)
        else:
            break

    # Create the snake_case output
    for s in snake:
        # Start the string
        if s == snake[0]:
            snake_case = s
            # print(snake_case)
        else:
            snake_case = snake_case + '_' +str(s.lower())
            # print(snake_case)

    print(f"snake_case: {snake_case}")



main()

```

:::{#nte-list_manipulation .callout-note}
## Manipulating Lists
Lists in Python use *zero indexing* and can be created with literal syntax `[]` or formal syntax `list()`. You can manipulate lists using literal syntax and various formal methods and functions, as show in @lst-2_camel.
:::

:::{#imp-data_quality_checks .callout-important}
## Built-In Data Quality Checks
Data quality is one of the top issues plaguing data engineers, scientiests, analysts, and beyond right now. It's important to understand your output and why your code is operating in the way it is. As you saw above, I added a variable `start = 1` to essentially serve as a binary check. Once the loop ran once and the list was started, `start -= 1` so the rest of the conditional runs, but only checks the letter's case. This is because if the first and last letter of a word are the same, the conditional interpreted that as the start of a new word, rather than the end of the first.
:::

```{python}
#| lst-label: lst-2_coke
#| lst-cap: Coke Machine
#| code-line-numbers: true

# Build the main function
def main():

    # Initial money needed to buy the Coke
    due = 50
    # Initialize a start flag
    start = 1
    # Repeat while > 0
    while due > 0:
        if start == 1:
            # Provide the amount of money owed
            print(f"Amount Due: {due}")
            # Prompt the user for the coin
            coin = int(25)
            # Stop this conditional from repeating
            start -= 1
        # Ensure the coin is a nickle, dime, or quarter
        if coin not in [25, 10, 5]:
            due = due
            print(f"Amount Due: {due}")
            coin = int(25)
        elif coin in [25, 10, 5]:
            due = due - coin
            if due > 0:
                print(f"Amount Due: {due}")
                coin = int(25)
            elif due <= 0:
                print(f"Change Owed: {abs(due)}")
                break


main()

```

```{python}
#| lst-label: lst-2_twttr
#| lst-cap: Just Setting up my twttr
#| code-line-numbers: true

# Build the main function
def main():
    # Prompt the user for a string
    inp = "Hello, I am Chris and THIS is_a test."
    # Create a list of vowels
    vow = ['A', 'E', 'I', 'O', 'U']

    for i in inp:
        if i.upper() in vow:
            inp = inp.replace(i, "")
        else:
            inp = inp


    print(inp)



main()

```

```{python}
#| lst-label: lst-2_plates
#| lst-cap: Vanity Plates
#| code-line-numbers: true

# Build the main function
def main():
    # Get the plate, assuming it will be all uppercase
    plate = "TSTPL8"

    # Check if the plate is valid
    if is_valid(plate):
        print("Valid")
    else:
        print("Invalid")


def is_valid(s):
    # Check the first two values in s
    if not s[:2].isalpha():
        return False
    # Check the length of s
    if not 2 <= len(s) <= 6:
        return False
    # Numbers cannot be used in the middle of a plate
    for n, i in enumerate(s):
        if i.isdigit() and not s[n:].isdigit():
            return False
    # 0 can't be the first number
    for n, i in enumerate(s):
        if i == '0' and s[0:n].isalpha():
            return False
    # No punctuation, spaces, special characters, etc.
    if not s.isalnum():
        return False

    return True



main()

```

```{python}
#| lst-label: lst-2_nutrition
#| lst-cap: Nutrition Facts
#| code-line-numbers: true

# Build the main function
def main():
    # Prompt the user for the fruit
    fruit = "honeydew melon"
    # Return the calories
    cal_calc(fruit)

# Build the calorie calculator
def cal_calc(f):
    # Dictionary with the fruit and its calories per portion
    cal_dict = {
        "Apple": 130,
        "Avocado": 50,
        "Banana": 110,
        "Cantaloupe": 50,
        "Grapefruit": 60,
        "Grapes": 90,
        "Honeydew Melon": 50,
        "Kiwifruit": 90,
        "Lemon": 15,
        "Lime": 20,
        "Nectarine": 60,
        "Orange": 80,
        "Peach": 60,
        "Pear": 100,
        "Pineapple": 50,
        "Plums": 70,
        "Strawberries": 50,
        "Sweet Cherries": 100,
        "Tangerine": 50,
        "Watermelon": 80
    }
    # Check to see if the fruit is listed
    for k, v in cal_dict.items():
        if f.casefold() == k.casefold():
            return print(f"Calories: {v}")

    return None

main()

```

# Unit 3: Exceptions {#sec-unit_3}
## Lecture 3 {#sec-lecture_3}
- Exceptions are things that go wrong within our code
- A syntax error (or parsing error) is a common type of error that most python users encounter early on
  - Happens when code is entered incorrectly
  - The parser repeats the line with arrows pointing at the token in the line where the error occurred
- Runtime errors are those created by unexpected behavior in your code and include many types:
  - Some of the types are included in base python, some are specific to libraries
  - ***ZeroDivisionError***
  - ***NameError***
  - ***TypeError***
- Error Handling refers to the way you specify a solution to the user of the code
  - If there are common errors, you can build in your solutions to error messages

:::{#nte-Error_Documentation .callout-note}
## Error Documentation
For more information on errors and error handling, as well as how Python processes both, checkout the official documentation on the subject: [Errors and Exceptions](https://docs.python.org/3/tutorial/errors.html)
:::

### try {#sec-try}
- In Python, `try` and `except` are ways of testing user/code input before something goes wrong
  - The try block of code will attempt to run the code on the subsequent indented lines, after the colon
  - If the `try` block isn't successful, it generates an `exception` or `error`
  - If you just use `except:` after a try block, it will do whatever you intend, regardless of the ***type*** of error
- The code below will attempt to store a user input value, x, as an int and then print it
  - If the error is a value error, it prints the specified message
```{python}
try:
    x = int("10")
    print(f"x is {x}")
except ValueError:
    print("x is not an integer")
```

- We can improve the code in a few ways
  - It's best practice to `try` as few lines of code as possible; however, the following generates a different kind of error
  - There's an error storing the variable x because Python can't convert the string `"test"` to type `int`
  - So, Python excepts a `NameError` instead of a `ValueError` because `name 'x' is not defined`
```{python}
#| output: false

try:
    x = int("test")
except ValueError:
    print("x is not an integer")

print(f"x is {x}")
```

- You can work around this error handling mismatch with another implementation of `try ... except`
```{python}
try:
    x = int("test")
except ValueError:
    print("x is not an integer")
else:
    print(f"x is {x}")
```

- If Python doesn't catch an exception then it runs the block of code after `else`
- You could further improve this code by adding a loop that will run forever, unless the right condition is met
```{python}
while True:
    try:
        x = int(10)
    except ValueError:
        print("x is not an integer")
    else:
        break

print(f"x is {x}")
```

- To best implement this, refactor the code to use UDFs, abstracting the loop from the main function
  - Note, `return` can also `break` your program out of a loop **and** it returns a value
  - The following code could have an else block that returns a value that is stored in the `try` block; however, the pattern used accomplishes the same output, with less code
```{python}
def main():
    x = get_int()
    print(f"x is {x}.")

def get_int():
    while True:
        try:
            return int(10)
        except ValueError:
            print("x is not an integer")

main()
```

- The final piece of error handling basics in Python is the `pass` command
  - Simply put, it tells Python to do nothing upon encountering an error
  - In the context of our code example, it will not print "x is not an integer" just reprompt the user
```{python}
def main():
    x = get_int(10.0)
    print(f"x is {x}")


def get_int(prompt):
    while True:
        try:
            return int(prompt)
        except ValueError:
            pass


main()
```

## Problem Set 3 {#sec-problem_set_3}
```{python}
#| lst-label: lst-3_fuel
#| lst-cap: Fuel Gauge
#| code-line-numbers: true

# Build the main function
def main():
    # Prompt the user for a fraction
    p = frac("5/20")
    # Print F, the percentage, or E
    if p <= 0.01 or p >= 0.99:
        match p:
            case _ if p <= 0.01:
                print("E")
            case _ if p >= 0.99:
                print("F")
            case _:
                print("F/E error")
                return
    # Print the percent with the percentage sign
    elif 0.01 < p < 0.99:
        print(f"{int(p*100)}%")

# Build the function for getting the fraction and converting it to a float
def frac(prompt):
    # Initiate a loop to ensure data quality
    while True:
        try:
            # Store the user input and then output it
            f = prompt
            # Store the fraction as a list to separate out the numeric elements
            f = f.split('/')
            # Store the numerator and denominator as x and y
            x = int(f[0])
            y = int(f[1])
            # Verify that Y > X
            if x > y:
                pass
            else:
                return round(x / y, 2)
        except ValueError:
            pass
        except ZeroDivisionError:
            pass

main()
```

```{python}
#| lst-label: lst-3_taqueria
#| lst-cap: Felipe's Taqueria
#| code-line-numbers: true

# Build the main function
def main():
    # Define the food items
    menu = {
    "Baja Taco": 4.25,
    "Burrito": 7.50,
    "Bowl": 8.50,
    "Nachos": 11.00,
    "Quesadilla": 8.50,
    "Super Burrito": 8.50,
    "Super Quesadilla": 9.50,
    "Taco": 3.00,
    "Tortilla Salad": 8.00
    }
    # Create a loop to continuously prompt the users
    total_ord = 0

    #while True:
    try:
        # Prompt the user
        item_food = food("taco").title()
        # Reprompt the user if the food isn't on the menu
        if item_food in menu.keys():
            # Return the total
            total_ord = round(total_ord + menu.get(item_food), 2)
            print(f"Total: ${total_ord:.2f}")
        else:
            return
    except EOFError:
        return print("")

# Build the food input function
def food(prompt):
    f = str(prompt) 
    return f

main()

```

```{python}
#| lst-label: lst-3_grocery
#| lst-cap: Grocery List
#| code-line-numbers: true



```

```{python}
#| lst-label: lst-3_outdated
#| lst-cap: Outdated
#| code-line-numbers: true



```