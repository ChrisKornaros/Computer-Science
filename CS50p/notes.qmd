---
title: CS50p Notes by Unit
format: html
theme: solar
toc: true
toc-location: left
toc-expand: true
fontcolor: "#ECEFF1"
# Still want to change/configure the background color for the callout boxes
code-copy: hover
code-line-numbers: true
code-block-bg: "#37474F"
---
# Document Introduction {#sec-introduction .unnumbered}
## Git {#sec-git .unnumbered}
:::{}
- My local Computer_Science repo now has a specific branch for CS50p
  - Note, you can use git within the .venv or outside of it, git is unaffected by the virtual environment for CS50p.
```{zsh}
git checkout cs50p
git add .
git commit -m "Saving recent work for CS50p."
git checkout main
git merge --no-ff cs50p main
git push
```
:::

## Quarto and Markdown {#sec-quarto-markdown .unnumbered}
:::{}
- Quarto is used from the command line, the .qmd file uses markdown syntax
- Using Docker to spin up a container to run the quarto preview was clunky and complicated, still did not work
  - So, simplest solution is spinning up a virtual envionment in the folder I want to work from and then using the venv

### Some general markdown tips for .qmd files {#sec-md-tips .unnumbered}
- Even though there are general settings set at the top of the `.qmd` file, when settings are changed on specific objects, *all* of their settings must be configured, even the document's defaults
:::

:::{#nte-quarto_md_basics .callout-note .unnumbered}
## Quarto Markdown Basics

For more markdown tips, docs, and shortcuts <https://quarto.org/docs/authoring/markdown-basics.html>
:::

# Unit 0: Functions and Variables {#sec-unit_0 .unnumbered}
## Lecture 0 {#sec-lecture_0}
### Integers or `int` {#sec-integers}
:::{}
* F-string formatting is a way to embed variables in strings, simply use ```print(f"There are, {count} apples.")```
* In python an integer is referred to as an `int` 
* It's easy to interact with `int` variables natively in Python
```{python}
#| echo: true
x = 1
y = 2

z = x + y

print(z)
```
* You can improve upon the above program by using base Python functions
```{python}
x = 5#int(input("What's x? "))
y = 4#int(input("What's y? "))

print(x + y)
```
::: {#nte-hardcoded_variables .callout-note}
## Hardcoded Variable Values

Quarto does not support user input code rendering, so the file preview fails with functions like `input()`. As a result, appropriate values are hard-coded.
:::

:::

### Floats {#sec-floats}
:::{}
* A floating point value is a real number with a decimal, like `0.52`
* Modifying the previous code to use the `float` data type allows you to perform operations on decimals too
* When dealing with decimals, you may want or need to round the values
* You can tie everything together with the following code, which rounds the sum to 2 decimal places
  * Additionally, ```print(f"{z:,}")``` prints the variable `z` and adds a comma to the value
```{python}
# Get the user's input
x = 2#float(input("What's x? "))
y = 3.3#float(input("What's y? "))

# Create a rounded result
z = round(x + y, 2)

# Print the formatted result
print(f"{z:,}")
```
* Finally, you could remove the piece of code that rounds the values with f-string formatting
```{python}
# Get the user's input
x = 2.2#float(input("What's x? "))
y = 3.4#float(input("What's y? "))

# Calculate the result
z = x / y

# Print the result
print(f"{z:.2f}")
```
:::

::: {#nte-numeric_operators .callout-note}
## Python Numeric Operators

Python has several built-in operators for numeric data types: `+`, `-`, `*`, `/`, `** (exponentiation)`, `% (remainder)`.
:::

### Def (User Defined Functions) {#sec-udf}
:::{}
* Use the `def` keyword to initialize a UDF (user-defined function)
* Follow this with the function name, parentheses, and then any conditions in the parentheses
```{python}
def hello():
    print("hello")


name = "Chris"#input("What's your name? ")
hello()
print(name)
```
* Notice how everything is indented under def, Python uses indentation to understand what's part of the function
* Similar to other programming languages, Python utilizes main functions in scripts for the primary purpose
* Utilize a main function and return a value as follows
```{python}
def main():
    x = 3#int(input("What's x? "))
    print("x squared is", square(x))


def square(n):
    return n * n


main()
```
:::

## Problem Set 0 {#sec-problem-set-0}
```{python}
#| lst-label: lst-0_indoor
#| lst-cap: Indoor Voice
#| code-line-numbers: true

# Problem Set 0, Problem 1
# Prompt the user for input
def ask_user():
    global a
    a = "MY NAME IS WD-40"
    return a

# Lowercase the string


def a_lower():
    print(a.lower())


ask_user()
a_lower()

```
```{python}
#| lst-label: lst-0_playback
#| lst-cap: Playback Speed
#| code-line-numbers: true

# Prompt the user for input
def ask_user():
    global a
    a = "Hello, it's very nice to meet you!"
    return a

# Add the three periods


def playback():
    b = a.replace(' ', '...')
    print(b)


ask_user()
playback()
```
```{python}
#| lst-label: lst-0_faces
#| lst-cap: Making Faces
#| code-line-numbers: true

# Build main function
def main():
    # Prompt the user for a value
    a = ":)"

    # Conver the input
    b = convert(a)

    return print(b)

# Build the convert function
def convert(val):
    # Replace the slightly smiling and slightly frowning faces in place and overwrite the input variable
    val = str(val).replace(":)", "\U0001F642").replace(":(", "\U0001f641")

    return val


main()
```
```{python}
#| lst-label: lst-0_einstein
#| lst-cap: Einstein
#| code-line-numbers: true

def main():
    # Prompt the user for an integer
    m = int(50)

    # Store the speed of light
    c = 300000000

    # Calculate the energy
    e = m * (c ** 2)

    return print(f"E: {e}")

main()
```
```{python}
#| lst-label: lst-0_tip
#| lst-cap: Tip Calculator
#| code-line-numbers: true

def main():
    meal = dollars_to_float("76.50")
    percent = percent_to_float("20%")
    tip = meal * percent
    print(f"Leave ${tip:.2f}")


def dollars_to_float(d):
    # Should accept a str as input in excepted format of $##.## and remove the leading $
    d = d.replace("$", "")
    # Convert d to a float
    d = float(d)

    return d


def percent_to_float(p):
    # Should accept a str as input in expected format of ##% and remove the trailing %
    p = p.replace("%", "")
    # Return p as a percentage, stored as a decimal float
    p = float(p) * 0.01

    return p


main()
```
# Unit 1: Conditionals {#sec-unit_1}
## Lecture 1 {#sec-lecture_1}
:::{}
- Conditionals allow you to provide specific instructions in your program on how to handle various situations
- Python has a set of built-in operators to compare a left hand term to a right hand term
  - `> and <` are what you expect: greater than and less than, respectively. 
  - `>= and <=` follow the same pattern as above: greater than or equal to and less than or equal to, respectively.
  - `== and !=` this denotes equal to and not equal to, respectively.
:::

::: {#nte-equal_sign_diff .callout-note}
## Difference betweeen `=` and `==`

Using a single `=` will assign a value on the right to the value on the left: `x = 2`; however, the double `==` will check if the value on the right equals the value on the left `x == 2`.  
:::

### if Statements {#sec-if}
::: {}
- `if` Statements use `bool` or boolean values (`true or false`) to decide whether to execute
- To better understand if statement behavior look at the following code:
```{python}
x = 5
y = 4

if x < y:
    print("x is less than y")
if x > y:
    print("x is greater than y")
if x == y:
    print("x is equal to y")
```
- Python evaluates the first if statement and sees that 5 is not less than 4, so it does nothing
  - Then, Python evaluates the second if statement and see that 5 is greater than 4, so it prints the message
  - As a result, the program stops and the third statement is not evaluated (even though the third statement is not true anyways)
  - This "flow" of decisions is called **`control flow`**
- You can improve upon this flow using the `if` `elif` `else` syntax
```{python}
x = 5
y = 5

if x < y:
    print("x is less than y")
elif x > y:
    print("x is greater than y")
else:
    print("x is equal to y")
```
:::

### or Statements {#sec-or}
:::{}
- `or` allows your program to decide between one or more alternatives
- When dealing with multiple conditions, using *or* can drastically decrease code complexity
```{python}
x = 5
y = 7

if (x < y) or (x > y):
    print("x is not equal to y")
else:
    print("x is equal to y")
```
- This code block works, but we could improve upon it further by just checking to see if `x == y` or `x != y`
:::

### and Statements {#sec-and}
:::{}
- `and` statements are another type of conditional, they check whether something meets multiple conditions simultaneously 
- Starting with the following code, let's make some readability and functionality improvements
```{python}
score = 78
if score >= 90 and score <= 100:
    print("Grade: A")
elif score >= 80 and score < 90:
    print("Grade: B")
elif score >= 70 and score < 80:
    print("Grade: C")
elif score >= 60 and score < 70:
    print("Grade: D")
else:
    print("Grade: F")
```
- A nice feature of python is you can chain together conditionals in an easy to understand format
```{python}
score = 81
if 90 <= score <= 100:
    print("Grade: A")
elif 80 <= score < 90:
    print("Grade: B")
elif 70 <= score < 80:
    print("Grade: C")
elif 60 <= score < 70:
    print("Grade: D")
else:
    print("Grade: F")
```
- Again, similar to `or` it's best to ask the simplest question in a conditional
```{python}
score = 90
if score >= 90:
    print("Grade: A")
elif score >= 80:
    print("Grade: B")
elif score >= 70:
    print("Grade: C")
elif score >= 60:
    print("Grade: D")
else:
    print("Grade: F")
```
:::

### Modulo {#sec-modulo}
:::{}
- Mentioned briefly in [@nte-numeric_operators], the `%` operator shows whether a number divides evenly or with a remainder
  - For example, `24 % 2` evaluates to `0`, but `24 % 5` evaluates to 4 the *remainder*
  - In mathematics, whether something is even or odd is referred to as parity
- Discussed in [Unit @sec-udf] it's useful to create your own functions
```{python}
def main():
    x = 21
    if is_even(x):
        print("Even")
    else:
        print("Odd")

def is_even(n):
    if n % 2 == 0:
        return True
    else:
        return False

main()
```
- In programming, the phrase *Pythonic* refers to a way to code something that only occurs in Python
- You can further refine your code and abstract away some of the process using native Python functionality
- Simplify `is_even(n)` to the following
  - Recall that `==` evaluates whether something is equal or not, it returns a `Bool`
```{python}
def main():
    x = 94
    if is_even(x):
        print("Even")
    else:
        print("Odd")

def is_even(n):
    return n % 2 == 0

main()
```
:::

### match Statements {#sec-match}
:::{}
- Similar to other conditional statements, `match` can be used to run code that matches a certain value
- The structure follows the Python pattern of identation with conditions and uses the keywords `match` and `case`
```{python}
name = "Ron"

match name:
    case "Harry":
        print("Gryffindor")
    case "Ron":
        print("Gryffindor")
    case "Hermione":
        print("Gryffindor")
    case "Draco":
        print("Slytherin")
    case _:
        print("Who?")
```
- The `_` functions similar to an `else` statement as it takes in all values
- This statement compares the value following `match` with each value following `case`
  - In the event a match is found, the indented code is executed and the search *stops*
- Improve upon the code by using the `|` operator, which equates to `or` and checks multiple values in the same case statement
```{python}
name = "Hermione"

match name:
    case "Harry" | "Ron" | "Hermione":
        print("Gryffindor")
    case "Draco":
        print("Slytherin")
    case _:
        print("Who?")
```
:::

## Problem Set 1 {#sec-problem-set-1}
```{python}
#| lst-label: lst-1_thought
#| lst-cap: Deep Thought
#| code-line-numbers: true

# Build the main function
def main():
    # Prompt the user for the answer to the Great Question of Life, the Universe and Everything
    ans = ("ForTy-tWo").lower().strip()

    match ans:
        case "42" | "forty-two" | "forty two":
            return print("Yes")
        case _:
            return print("No")


main()
```
:::{#tip-case_conditions .callout-tip}
## Case Conditions

The `case _ if` syntax allows you to add conditions to each case when using a match statement. Combine this with the `in` operator to perform searches in strings: `case _ if h in hello`. 
:::
```{python}
#| lst-label: lst-1_bank
#| lst-cap: Home Federal Savings Bank
#| code-line-numbers: true

# Build the main function
def main():
    # Prompt the user for a greeting
    greet = ("How you doing?").lower().strip()

    # Decide how much money the user gets
    match greet:
         case _ if greet.startswith("hello"):
              return print("$0")
         case _ if greet.startswith("h"):
              return print("$20")
         case _:
              return print("$100")


main()
```
```{python}
#| lst-label: lst-1_file
#| lst-cap: File Extensions
#| code-line-numbers: true

# Build the main function
def main():
    # Put the necessary extensions in a tuple
    ext = (".gif", ".jpg", ".jpeg", ".png", ".pdf", ".txt", ".zip")
    # Group those into MIME types
    mime = ("image/gif", "image/jpeg", "image/png", "application/pdf", "text/plain", "application/zip")
    # Get the user's file
    file = "virus.png".lower().strip()

    # Check which MIME type the file is and return the value
    if file.endswith(ext):
        if file.split('.')[-1] == ext[1].split('.')[-1] or file.split('.')[-1] == ext[2].split('.')[-1]:
            return print(mime[1])
        elif file.split('.')[-1] == ext[0].split('.')[-1]:
            return print(mime[0])
        elif file.split('.')[-1] == ext[3].split('.')[-1]:
            return print(mime[2])
        elif file.split('.')[-1] == ext[4].split('.')[-1]:
            return print(mime[3])
        elif file.split('.')[-1] == ext[-2].split('.')[-1]:
            return print(mime[-2])
        else:
            return print(mime[-1])
    else:
        return print("application/octet-stream")


main()
```
:::{#nte-repetitive_code .callout-note}
There are far more efficient ways to do the above, including using a dictionary and iterators. Those are covered in the next unit.
:::
```{python}
#| lst-label: lst-1_math
#| lst-cap: Math Interpreter
#| code-line-numbers: true

# Build the main function
def main():
    # Prompt the user for an expression
    exp = "52 / 6"

    # Split the expression into x, y, and z
    x, y, z = exp.split(' ')

    # Ensure Data Quality
    x = float(x)
    z = float(z)

    # Evaluate the expression
    match y:
        case _ if y == '+':
            return print(x + z)
        case _ if y == '-':
            return print(x - z)
        case _ if y == '*':
            return print(x * z)
        case _ if y == '/':
            return print(x / z)
        case _:
            return 0


main()
```
```{python}
#| lst-label: lst-1_meal
#| lst-cap: Meal Time
#| code-line-numbers: true

# Build the main function
def main():
    # Prompt the user for the time
    ut = "7:03"

    # Convert the time to a float
    tm = convert(ut)

    # Return what meal corresponds to the time, if any
    match tm:
        case _ if 7.00 <= tm <= 8.00:
            return print("breakfast time")
        case _ if 12.00 <= tm <= 13.00:
            return print("lunch time")
        case _ if 18.00 <= tm <= 19.00:
            return print("dinner time")
        case _:
            return exit

def convert(time):
    # Convert the string via code that performs several operations at once
    # The string time is split at the ':', the first item is converted to float
    # The Second item is converted to float and then divided by 60 to convert it to a decimal
    time = float(time.split(":")[0]) + float(time.split(":")[1])/60

    return time



if __name__ == '__main__':
    main()
```

# Unit 2: Loops {#sec-unit_2}
## Lecture 2 {#sec-lecture_2}