---
title: CS50p Notes by Unit
format: html
theme: solar
toc: true
toc-location: left
toc-expand: true
fontcolor: "#ECEFF1"
# Still want to change/configure the background color for the callout boxes
code-copy: hover
code-line-numbers: true
code-block-bg: "#37474F"
---
# Document Introduction {#sec-introduction .unnumbered}
## Git {#sec-git .unnumbered}
- My local Computer_Science repo now has a specific branch for CS50p
  - Note, you can use git within the .venv or outside of it, git is unaffected by the virtual environment for CS50p.
```{zsh}
git checkout cs50p
git add .
git commit -m "Saving recent work for CS50p."
git checkout main
git merge --no-ff cs50p main
git push
```

## Quarto and Markdown {#sec-quarto-markdown .unnumbered}
- Quarto is used from the command line, the .qmd file uses markdown syntax
- Using Docker to spin up a container to run the quarto preview was clunky and complicated, still did not work
  - So, simplest solution is spinning up a virtual envionment in the folder I want to work from and then using the venv

### Some general markdown tips for .qmd files {#sec-md-tips .unnumbered}
- Even though there are general settings set at the top of the `.qmd` file, when settings are changed on specific objects, *all* of their settings must be configured, even the document's defaults

:::{#nte-quarto_md_basics .callout-note .unnumbered}
#### Quarto Markdown Basics

For more markdown tips, docs, and shortcuts <https://quarto.org/docs/authoring/markdown-basics.html>
:::

# Unit 0: Functions and Variables {#sec-unit_0 .unnumbered}
## Lecture 0 {#sec-lecture_0}
### Integers or `int` {#sec-integers}
- F-string formatting is a way to embed variables in strings, simply use ```print(f"There are, {count} apples.")```
- In python an integer is referred to as an `int` 
- It's easy to interact with `int` variables natively in Python
```{python}
#| echo: true
#| eval: false

x = 1
y = 2

z = x + y

print(z)
```
- You can improve upon the above program by using base Python functions
```{python}
#| eval: false

x = 5#int(input("What's x? "))
y = 4#int(input("What's y? "))

print(x + y)
```
::: {#nte-hardcoded_variables .callout-note}
#### Hardcoded Variable Values

Quarto does not support user input code rendering, so the file preview fails with functions like `input()`. As a result, appropriate values are hard-coded.
:::

### Floats {#sec-floats}
- A floating point value is a real number with a decimal, like `0.52`
- Modifying the previous code to use the `float` data type allows you to perform operations on decimals too
- When dealing with decimals, you may want or need to round the values
- You can tie everything together with the following code, which rounds the sum to 2 decimal places
  - Additionally, ```print(f"{z:,}")``` prints the variable `z` and adds a comma to the value
```{python}
#| eval: false

# Get the user's input
x = 2#float(input("What's x? "))
y = 3.3#float(input("What's y? "))

# Create a rounded result
z = round(x + y, 2)

# Print the formatted result
print(f"{z:,}")
```
- Finally, you could remove the piece of code that rounds the values with f-string formatting
```{python}
#| eval: false

# Get the user's input
x = 2.2#float(input("What's x? "))
y = 3.4#float(input("What's y? "))

# Calculate the result
z = x / y

# Print the result
print(f"{z:.2f}")
```

::: {#nte-numeric_operators .callout-note}
#### Python Numeric Operators

Python has several built-in operators for numeric data types: `+`, `-`, `*`, `/`, `** (exponentiation)`, `% (remainder)`.
:::

### Def (User Defined Functions) {#sec-udf}
* Use the `def` keyword to initialize a UDF (user-defined function)
* Follow this with the function name, parentheses, and then any conditions in the parentheses
```{python}
#| eval: false

def hello():
    print("hello")


name = "Chris"#input("What's your name? ")
hello()
print(name)
```
- Notice how everything is indented under def, Python uses indentation to understand what's part of the function
- Similar to other programming languages, Python utilizes main functions in scripts for the primary purpose
- Utilize a main function and return a value as follows
```{python}
#| eval: false

def main():
    x = 3#int(input("What's x? "))
    print("x squared is", square(x))


def square(n):
    return n * n


main()
```

## Problem Set 0 {#sec-problem-set-0}
```{python}
#| lst-label: lst-0_indoor
#| lst-cap: Indoor Voice
#| code-line-numbers: true
#| eval: false

# Problem Set 0, Problem 1
# Prompt the user for input
def ask_user():
    global a
    a = "MY NAME IS WD-40"
    return a

# Lowercase the string


def a_lower():
    print(a.lower())


ask_user()
a_lower()

```
```{python}
#| lst-label: lst-0_playback
#| lst-cap: Playback Speed
#| code-line-numbers: true
#| eval: false

# Prompt the user for input
def ask_user():
    global a
    a = "Hello, it's very nice to meet you!"
    return a

# Add the three periods


def playback():
    b = a.replace(' ', '...')
    print(b)


ask_user()
playback()
```
```{python}
#| lst-label: lst-0_faces
#| lst-cap: Making Faces
#| code-line-numbers: true
#| eval: false

# Build main function
def main():
    # Prompt the user for a value
    a = ":)"

    # Conver the input
    b = convert(a)

    return print(b)

# Build the convert function
def convert(val):
    # Replace the slightly smiling and slightly frowning faces in place and overwrite the input variable
    val = str(val).replace(":)", "\U0001F642").replace(":(", "\U0001f641")

    return val


main()
```
```{python}
#| lst-label: lst-0_einstein
#| lst-cap: Einstein
#| code-line-numbers: true
#| eval: false

def main():
    # Prompt the user for an integer
    m = int(50)

    # Store the speed of light
    c = 300000000

    # Calculate the energy
    e = m * (c ** 2)

    return print(f"E: {e}")

main()
```
```{python}
#| lst-label: lst-0_tip
#| lst-cap: Tip Calculator
#| code-line-numbers: true
#| eval: false

def main():
    meal = dollars_to_float("76.50")
    percent = percent_to_float("20%")
    tip = meal * percent
    print(f"Leave ${tip:.2f}")


def dollars_to_float(d):
    # Should accept a str as input in excepted format of $##.## and remove the leading $
    d = d.replace("$", "")
    # Convert d to a float
    d = float(d)

    return d


def percent_to_float(p):
    # Should accept a str as input in expected format of ##% and remove the trailing %
    p = p.replace("%", "")
    # Return p as a percentage, stored as a decimal float
    p = float(p) * 0.01

    return p


main()
```
# Unit 1: Conditionals {#sec-unit_1}
## Lecture 1 {#sec-lecture_1}
- Conditionals allow you to provide specific instructions in your program on how to handle various situations
- Python has a set of built-in operators to compare a left hand term to a right hand term
  - `> and <` are what you expect: greater than and less than, respectively. 
  - `>= and <=` follow the same pattern as above: greater than or equal to and less than or equal to, respectively.
  - `== and !=` this denotes equal to and not equal to, respectively.

::: {#nte-equal_sign_diff .callout-note}
#### Difference betweeen `=` and `==`

Using a single `=` will assign a value on the right to the value on the left: `x = 2`; however, the double `==` will check if the value on the right equals the value on the left `x == 2`.  
:::

### if Statements {#sec-if}
- `if` Statements use `bool` or boolean values (`true or false`) to decide whether to execute
- To better understand if statement behavior look at the following code:
```{python}
#| eval: false

x = 5
y = 4

if x < y:
    print("x is less than y")
if x > y:
    print("x is greater than y")
if x == y:
    print("x is equal to y")
```
- Python evaluates the first if statement and sees that 5 is not less than 4, so it does nothing
  - Then, Python evaluates the second if statement and see that 5 is greater than 4, so it prints the message
  - As a result, the program stops and the third statement is not evaluated (even though the third statement is not true anyways)
  - This "flow" of decisions is called **`control flow`**
- You can improve upon this flow using the `if` `elif` `else` syntax
```{python}
#| eval: false

x = 5
y = 5

if x < y:
    print("x is less than y")
elif x > y:
    print("x is greater than y")
else:
    print("x is equal to y")
```

### or Statements {#sec-or}
- `or` allows your program to decide between one or more alternatives
- When dealing with multiple conditions, using *or* can drastically decrease code complexity
```{python}
#| eval: false

x = 5
y = 7

if (x < y) or (x > y):
    print("x is not equal to y")
else:
    print("x is equal to y")
```
- This code block works, but we could improve upon it further by just checking to see if `x == y` or `x != y`

### and Statements {#sec-and}
- `and` statements are another type of conditional, they check whether something meets multiple conditions simultaneously 
- Starting with the following code, let's make some readability and functionality improvements
```{python}
#| eval: false

score = 78
if score >= 90 and score <= 100:
    print("Grade: A")
elif score >= 80 and score < 90:
    print("Grade: B")
elif score >= 70 and score < 80:
    print("Grade: C")
elif score >= 60 and score < 70:
    print("Grade: D")
else:
    print("Grade: F")
```

- A nice feature of python is you can chain together conditionals in an easy to understand format
```{python}
#| eval: false

score = 81
if 90 <= score <= 100:
    print("Grade: A")
elif 80 <= score < 90:
    print("Grade: B")
elif 70 <= score < 80:
    print("Grade: C")
elif 60 <= score < 70:
    print("Grade: D")
else:
    print("Grade: F")
```

- Again, similar to `or` it's best to ask the simplest question in a conditional
```{python}
#| eval: false

score = 90
if score >= 90:
    print("Grade: A")
elif score >= 80:
    print("Grade: B")
elif score >= 70:
    print("Grade: C")
elif score >= 60:
    print("Grade: D")
else:
    print("Grade: F")
```

### Modulo {#sec-modulo}
- Mentioned briefly in [@nte-numeric_operators], the `%` operator shows whether a number divides evenly or with a remainder
  - For example, `24 % 2` evaluates to `0`, but `24 % 5` evaluates to 4 the *remainder*
  - In mathematics, whether something is even or odd is referred to as parity
- Discussed in [Unit @sec-udf] it's useful to create your own functions
```{python}
#| eval: false

def main():
    x = 21
    if is_even(x):
        print("Even")
    else:
        print("Odd")

def is_even(n):
    if n % 2 == 0:
        return True
    else:
        return False

main()
```
- In programming, the phrase *Pythonic* refers to a way to code something that only occurs in Python
- You can further refine your code and abstract away some of the process using native Python functionality
- Simplify `is_even(n)` to the following
  - Recall that `==` evaluates whether something is equal or not, it returns a `Bool`
```{python}
#| eval: false

def main():
    x = 94
    if is_even(x):
        print("Even")
    else:
        print("Odd")

def is_even(n):
    return n % 2 == 0

main()
```

### match Statements {#sec-match}
- Similar to other conditional statements, `match` can be used to run code that matches a certain value
- The structure follows the Python pattern of identation with conditions and uses the keywords `match` and `case`
```{python}
#| eval: false

name = "Ron"

match name:
    case "Harry":
        print("Gryffindor")
    case "Ron":
        print("Gryffindor")
    case "Hermione":
        print("Gryffindor")
    case "Draco":
        print("Slytherin")
    case _:
        print("Who?")
```
- The `_` functions similar to an `else` statement as it takes in all values
- This statement compares the value following `match` with each value following `case`
  - In the event a match is found, the indented code is executed and the search *stops*
- Improve upon the code by using the `|` operator, which equates to `or` and checks multiple values in the same case statement
```{python}
#| eval: false

name = "Hermione"

match name:
    case "Harry" | "Ron" | "Hermione":
        print("Gryffindor")
    case "Draco":
        print("Slytherin")
    case _:
        print("Who?")
```

## Problem Set 1 {#sec-problem_set_1}
```{python}
#| lst-label: lst-1_thought
#| lst-cap: Deep Thought
#| code-line-numbers: true
#| eval: false

# Build the main function
def main():
    # Prompt the user for the answer to the Great Question of Life, the Universe and Everything
    ans = ("ForTy-tWo").lower().strip()

    match ans:
        case "42" | "forty-two" | "forty two":
            return print("Yes")
        case _:
            return print("No")


main()
```
:::{#tip-case_conditions .callout-tip}
#### Case Conditions

The `case _ if` syntax allows you to add conditions to each case when using a match statement. Combine this with the `in` operator to perform searches in strings: `case _ if h in hello`. 
:::
```{python}
#| lst-label: lst-1_bank
#| lst-cap: Home Federal Savings Bank
#| code-line-numbers: true
#| eval: false

# Build the main function
def main():
    # Prompt the user for a greeting
    greet = ("How you doing?").lower().strip()

    # Decide how much money the user gets
    match greet:
         case _ if greet.startswith("hello"):
              return print("$0")
         case _ if greet.startswith("h"):
              return print("$20")
         case _:
              return print("$100")


main()
```
```{python}
#| lst-label: lst-1_file
#| lst-cap: File Extensions
#| code-line-numbers: true
#| eval: false

# Build the main function
def main():
    # Put the necessary extensions in a tuple
    ext = (".gif", ".jpg", ".jpeg", ".png", ".pdf", ".txt", ".zip")
    # Group those into MIME types
    mime = ("image/gif", "image/jpeg", "image/png", "application/pdf", "text/plain", "application/zip")
    # Get the user's file
    file = "virus.png".lower().strip()

    # Check which MIME type the file is and return the value
    if file.endswith(ext):
        if file.split('.')[-1] == ext[1].split('.')[-1] or file.split('.')[-1] == ext[2].split('.')[-1]:
            return print(mime[1])
        elif file.split('.')[-1] == ext[0].split('.')[-1]:
            return print(mime[0])
        elif file.split('.')[-1] == ext[3].split('.')[-1]:
            return print(mime[2])
        elif file.split('.')[-1] == ext[4].split('.')[-1]:
            return print(mime[3])
        elif file.split('.')[-1] == ext[-2].split('.')[-1]:
            return print(mime[-2])
        else:
            return print(mime[-1])
    else:
        return print("application/octet-stream")


main()
```
:::{#nte-repetitive_code .callout-note}
There are far more efficient ways to do the above, including using a dictionary and iterators. Those are covered in the next unit.
:::
```{python}
#| lst-label: lst-1_math
#| lst-cap: Math Interpreter
#| code-line-numbers: true
#| eval: false

# Build the main function
def main():
    # Prompt the user for an expression
    exp = "52 / 6"

    # Split the expression into x, y, and z
    x, y, z = exp.split(' ')

    # Ensure Data Quality
    x = float(x)
    z = float(z)

    # Evaluate the expression
    match y:
        case _ if y == '+':
            return print(x + z)
        case _ if y == '-':
            return print(x - z)
        case _ if y == '*':
            return print(x * z)
        case _ if y == '/':
            return print(x / z)
        case _:
            return 0


main()
```
```{python}
#| lst-label: lst-1_meal
#| lst-cap: Meal Time
#| code-line-numbers: true
#| eval: false

# Build the main function
def main():
    # Prompt the user for the time
    ut = "7:03"

    # Convert the time to a float
    tm = convert(ut)

    # Return what meal corresponds to the time, if any
    match tm:
        case _ if 7.00 <= tm <= 8.00:
            return print("breakfast time")
        case _ if 12.00 <= tm <= 13.00:
            return print("lunch time")
        case _ if 18.00 <= tm <= 19.00:
            return print("dinner time")
        case _:
            return exit

def convert(time):
    # Convert the string via code that performs several operations at once
    # The string time is split at the ':', the first item is converted to float
    # The Second item is converted to float and then divided by 60 to convert it to a decimal
    time = float(time.split(":")[0]) + float(time.split(":")[1])/60

    return time



if __name__ == '__main__':
    main()
```

# Unit 2: Loops {#sec-unit_2}
## Lecture 2 {#sec-lecture_2}
- Loops are a way of doing something over and over again
- Pretend you write the following block of code
```{python}
#| output: false
#| eval: false

print("meow")
print("meow")
print("meow")
```
- It's not going to be efficient to do this 20 times, let a few hundred, this is where loops are useful

### while Loops {#sec-while_loops}
- The `while` loops is nearly universal in all coding languages
- As its name says, it runs while a condition is `true` and until it is `false` or *vice versa*
  - Like with all processes run from a command line, use `Ctrl-C` to kill any hanging or infinitely running programs
- The term iteration is very significant with regards to coding, it refers to each cycle through a loop
- For a basic example of a while loop with an iteration counter:
```{python}
#| eval: false

i = 0
while i < 3:
    print("meow")
    i += 1
```

:::{#tip-add_sub_assignment .callout-tip}
#### Addition and Subtraction Assignment Operators
The `+=` and `-=` symbols are the addition and subtraction assignment operators, respectively. They are a great shortcut for iteratively adding values while looping. 
:::

### for Loops {#sec-for_loops}
- A `for` loop is used with what's called an `iterable` data type, like a `list` or `dictionary`
  - This is a crucial component of problem solving with Python, there will be several code examples to illustrate how it works
  - Using the same example as the while loop, look how clean the following is
``` {python}
#| output: false
#| eval: false

for i in [0, 1, 2]:
    print("meow")
``` 
- This can be further improved upon using the `range` data type, and the built-in `range()` function
```{python}
#| output: false
#| eval: false

for i in range(3):
    print("meow")
```

:::{#nte-underscore_wildcard .callout-note}
#### Use of the `_` as a wildcard operator
You can further simplifying things by removing the unused `i` and replacing it with a `_` to represent it. ***However,*** only do this when the variable you're replacing, in this case `i`, isn't used in the code.
:::

```{python}
#| output: false
#| eval: false

for _ in range(3):
    print("meow")
```
- Finally, you could write this out on one line, without the use of a loop (just as an example)
  - Adding the `\n` linebreak and `end=""` tells the compiler to add a linebreak at the end of each meow
```{python}
#| output: false
#| eval: false

print("meow\n" * 3, end="")
```
- You can bring out more of loops by combining their functionality
  - It's common to use `while` to validate user input
  - The keywords `continue` and `break` tell a loop to go to the next iteration of a loop or break out, respectively
  - See how you can tie together various kinds of loops with the following 
```{python}
#| output: false
#| eval: false

def main():
    meow(get_number())


def get_number():
    while True:
        n = int("5")
        if n > 0:
            return n


def meow(n):
    for _ in range(n):
        print("meow")


main()
```

### Iterables {#sec-iterables}
- Python uses what's called `zero indexing`, meaning object position indexes start at 0
- For iterables, like a `list`, `dict`, or `range` this is important when performing positional transformations
- Another useful function when talking about objects is `len`
  - For iterable data types, this will provide the *length* of an object
  - Combine this function with previous examples to simplify your code
```{python}
#| eval: false

students = ["Harry", "Ron", "Hermione"]

for i in range(len(students)):
    print(i + 1, students[i])
```
- `Dictionaries` are another core iterable type in Python, with numerous applications across specializations
  - Software Development
  - Data Engineering
  - Machine Learning
  - etc.
- While a list stores multiple values or objects (even other lists), a dictionary stores a key and values
- You could store students and houses in lists and try to keep their positions always lined up, but the issues are obvious
- A better approach is using a dictionary
```{python}
#| output: false
#| eval: false

students_list = ["Hermoine", "Harry", "Ron", "Draco"]
houses_list = ["Gryffindor", "Gryffindor", "Griffindor", "Slytherin"]

students = {
    "Hermoine": "Gryffindor",
    "Harry": "Gryffindor",
    "Ron": "Gryffindor",
    "Draco": "Slytherin",
}
for student in students:
    print(student, students[student], sep=", ")
```
- You could also expand your dictionary to have more information than just the Student and their House
```{python}
#| output: false
#| eval: false

students = [
    {"name": "Hermoine", "house": "Gryffindor", "patronus": "Otter"},
    {"name": "Harry", "house": "Gryffindor", "patronus": "Stag"},
    {"name": "Ron", "house": "Gryffindor", "patronus": "Jack Russell terrier"},
    {"name": "Draco", "house": "Slytherin", "patronus": None},
]

for student in students:
    print(student["name"], student["house"], student["patronus"], sep=", ")
```

### Mario {#sec-mario}
- The classic 2D Mario games are a great illustration of the use of loops
  - Similar to `meow` imagine printing three `#` in a vertical stack, just like blocks in Mario
  - You could do it one line of code at a time, or with a for loop
- You can easily modify the below code to print block width instead
- ```print("#" * n)``` instead of a loop will print the character n times on a line
```{python}
#| output: false
#| eval: false

# Build main function
def main():
    return block_height(3)

def block_height(n):
    for _ in range(n):
        print("#")

main()
```
- You can combine code for the height, with code for the width to print out a square
  - Doing so, you'll see how nested for loops behave
  - Notice the use of `end=""` which changes the default line end behavior of print from a line break `"\n"` to continuing on the same line
```{python}
#| eval: false

# Build main function
def main():
    # Get the height
    blocks = int(3)

    # Print the square
    for h in range(blocks):
        # Print the columns
        for w in range(blocks):
            print("#", end = "")
        # Print the rows
        print()

# Build the row function
def print_row(n):
    print("#" * n)

# Build the column function
def print_col(h):
    for _ in range(h):
        print("#")

main()
```

## Problem Set 2 {#sec-problem_set_2}
:::{#nte-camel_snake_case .callout-note}
#### camelCase and snake_case
Many times in code, you'll see variable names in various formats. Most commonly, you'll see `camelCase`, where the first word is lower case and then subsequent words have a capital first letter without a space separator, and `snake_case` where all words are lower case and they're separated by an `_`. 
:::
```{python}
#| lst-label: lst-2_camel
#| lst-cap: camelCase
#| code-line-numbers: true
#| eval: false

# Build the main function
def main():
    # Prompt the user for a variable in camelCase
    camel = "testThisProgramOutForMe".strip()

    # Convert the variable name to snake_case, first initialize a blank list
    snake = []
    # Iterate through the variable string
    # By adding a print() line in each iteration, I can check to see where code breaks
    start = 1
    for a in camel:
        # Start the snake list with the first letter in the camelCase variable
        # Data quality check: with the binary start variable, if the first letter in the first word is the same as the last, like in test
        # I am able to avoid any bugs/errors
        if a == camel[0] and start == 1:
            snake = snake + list(a)
            # print(snake)
            start -= 1
        # If lowercase, add it to the most recent list item
        elif a.islower():
            snake[-1] = snake[-1] + a
            # print(snake)
        # If uppercase, add a new list item
        elif a.isupper():
            snake = snake + list(a)
            # print(snake)
        else:
            break

    # Create the snake_case output
    for s in snake:
        # Start the string
        if s == snake[0]:
            snake_case = s
            # print(snake_case)
        else:
            snake_case = snake_case + '_' +str(s.lower())
            # print(snake_case)

    print(f"snake_case: {snake_case}")



main()

```

:::{#nte-list_manipulation .callout-note}
#### Manipulating Lists
Lists in Python use *zero indexing* and can be created with literal syntax `[]` or formal syntax `list()`. You can manipulate lists using literal syntax and various formal methods and functions, as show in @lst-2_camel.
:::

:::{#imp-data_quality_checks .callout-important}
#### Built-In Data Quality Checks
Data quality is one of the top issues plaguing data engineers, scientiests, analysts, and beyond right now. It's important to understand your output and why your code is operating in the way it is. As you saw above, I added a variable `start = 1` to essentially serve as a binary check. Once the loop ran once and the list was started, `start -= 1` so the rest of the conditional runs, but only checks the letter's case. This is because if the first and last letter of a word are the same, the conditional interpreted that as the start of a new word, rather than the end of the first.
:::

```{python}
#| lst-label: lst-2_coke
#| lst-cap: Coke Machine
#| code-line-numbers: true
#| eval: false

# Build the main function
def main():

    # Initial money needed to buy the Coke
    due = 50
    # Initialize a start flag
    start = 1
    # Repeat while > 0
    while due > 0:
        if start == 1:
            # Provide the amount of money owed
            print(f"Amount Due: {due}")
            # Prompt the user for the coin
            coin = int(25)
            # Stop this conditional from repeating
            start -= 1
        # Ensure the coin is a nickle, dime, or quarter
        if coin not in [25, 10, 5]:
            due = due
            print(f"Amount Due: {due}")
            coin = int(25)
        elif coin in [25, 10, 5]:
            due = due - coin
            if due > 0:
                print(f"Amount Due: {due}")
                coin = int(25)
            elif due <= 0:
                print(f"Change Owed: {abs(due)}")
                break


main()

```

```{python}
#| lst-label: lst-2_twttr
#| lst-cap: Just Setting up my twttr
#| code-line-numbers: true
#| eval: false

# Build the main function
def main():
    # Prompt the user for a string
    inp = "Hello, I am Chris and THIS is_a test."
    # Create a list of vowels
    vow = ['A', 'E', 'I', 'O', 'U']

    for i in inp:
        if i.upper() in vow:
            inp = inp.replace(i, "")
        else:
            inp = inp


    print(inp)



main()

```

```{python}
#| lst-label: lst-2_plates
#| lst-cap: Vanity Plates
#| code-line-numbers: true
#| eval: false

# Build the main function
def main():
    # Get the plate, assuming it will be all uppercase
    plate = "TSTPL8"

    # Check if the plate is valid
    if is_valid(plate):
        print("Valid")
    else:
        print("Invalid")


def is_valid(s):
    # Check the first two values in s
    if not s[:2].isalpha():
        return False
    # Check the length of s
    if not 2 <= len(s) <= 6:
        return False
    # Numbers cannot be used in the middle of a plate
    for n, i in enumerate(s):
        if i.isdigit() and not s[n:].isdigit():
            return False
    # 0 can't be the first number
    for n, i in enumerate(s):
        if i == '0' and s[0:n].isalpha():
            return False
    # No punctuation, spaces, special characters, etc.
    if not s.isalnum():
        return False

    return True



main()

```

```{python}
#| lst-label: lst-2_nutrition
#| lst-cap: Nutrition Facts
#| code-line-numbers: true
#| eval: false

# Build the main function
def main():
    # Prompt the user for the fruit
    fruit = "honeydew melon"
    # Return the calories
    cal_calc(fruit)

# Build the calorie calculator
def cal_calc(f):
    # Dictionary with the fruit and its calories per portion
    cal_dict = {
        "Apple": 130,
        "Avocado": 50,
        "Banana": 110,
        "Cantaloupe": 50,
        "Grapefruit": 60,
        "Grapes": 90,
        "Honeydew Melon": 50,
        "Kiwifruit": 90,
        "Lemon": 15,
        "Lime": 20,
        "Nectarine": 60,
        "Orange": 80,
        "Peach": 60,
        "Pear": 100,
        "Pineapple": 50,
        "Plums": 70,
        "Strawberries": 50,
        "Sweet Cherries": 100,
        "Tangerine": 50,
        "Watermelon": 80
    }
    # Check to see if the fruit is listed
    for k, v in cal_dict.items():
        if f.casefold() == k.casefold():
            return print(f"Calories: {v}")

    return None

main()

```

# Unit 3: Exceptions {#sec-unit_3}
## Lecture 3 {#sec-lecture_3}
- Exceptions are things that go wrong within our code
- A syntax error (or parsing error) is a common type of error that most python users encounter early on
  - Happens when code is entered incorrectly
  - The parser repeats the line with arrows pointing at the token in the line where the error occurred
- Runtime errors are those created by unexpected behavior in your code and include many types:
  - Some of the types are included in base python, some are specific to libraries
  - ***ZeroDivisionError***
  - ***NameError***
  - ***TypeError***
- Error Handling refers to the way you specify a solution to the user of the code
  - If there are common errors, you can build in your solutions to error messages

:::{#nte-Error_Documentation .callout-note}
#### Error Documentation
For more information on errors and error handling, as well as how Python processes both, checkout the official documentation on the subject: [Errors and Exceptions](https://docs.python.org/3/tutorial/errors.html)
:::

### try {#sec-try}
- In Python, `try` and `except` are ways of testing user/code input before something goes wrong
  - The try block of code will attempt to run the code on the subsequent indented lines, after the colon
  - If the `try` block isn't successful, it generates an `exception` or `error`
  - If you just use `except:` after a try block, it will do whatever you intend, regardless of the ***type*** of error
- The code below will attempt to store a user input value, x, as an int and then print it
  - If the error is a value error, it prints the specified message
```{python}
#| eval: false

try:
    x = int("10")
    print(f"x is {x}")
except ValueError:
    print("x is not an integer")
```

- We can improve the code in a few ways
  - It's best practice to `try` as few lines of code as possible; however, the following generates a different kind of error
  - There's an error storing the variable x because Python can't convert the string `"test"` to type `int`
  - So, Python excepts a `NameError` instead of a `ValueError` because `name 'x' is not defined`
```{python}
#| output: false
#| eval: false

try:
    x = int("test")
except ValueError:
    print("x is not an integer")

print(f"x is {x}")
```

- You can work around this error handling mismatch with another implementation of `try ... except`
```{python}
try:
    x = int("test")
except ValueError:
    print("x is not an integer")
else:
    print(f"x is {x}")
```

- If Python doesn't catch an exception then it runs the block of code after `else`
- You could further improve this code by adding a loop that will run forever, unless the right condition is met
```{python}
#| eval: false

while True:
    try:
        x = int(10)
    except ValueError:
        print("x is not an integer")
    else:
        break

print(f"x is {x}")
```

- To best implement this, refactor the code to use UDFs, abstracting the loop from the main function
  - Note, `return` can also `break` your program out of a loop **and** it returns a value
  - The following code could have an else block that returns a value that is stored in the `try` block; however, the pattern used accomplishes the same output, with less code
```{python}
#| eval: false

def main():
    x = get_int()
    print(f"x is {x}.")

def get_int():
    while True:
        try:
            return int(10)
        except ValueError:
            print("x is not an integer")

main()
```

- The final piece of error handling basics in Python is the `pass` command
  - Simply put, it tells Python to do nothing upon encountering an error
  - In the context of our code example, it will not print "x is not an integer" just reprompt the user
```{python}
#| eval: false

def main():
    x = get_int(10.0)
    print(f"x is {x}")


def get_int(prompt):
    while True:
        try:
            return int(prompt)
        except ValueError:
            pass


main()
```

## Problem Set 3 {#sec-problem_set_3}
```{python}
#| lst-label: lst-3_fuel
#| lst-cap: Fuel Gauge
#| code-line-numbers: true
#| eval: false

# Build the main function
def main():
    # Prompt the user for a fraction
    p = frac("5/20")
    # Print F, the percentage, or E
    if p <= 0.01 or p >= 0.99:
        match p:
            case _ if p <= 0.01:
                print("E")
            case _ if p >= 0.99:
                print("F")
            case _:
                print("F/E error")
                return
    # Print the percent with the percentage sign
    elif 0.01 < p < 0.99:
        print(f"{int(p*100)}%")

# Build the function for getting the fraction and converting it to a float
def frac(prompt):
    # Initiate a loop to ensure data quality
    while True:
        try:
            # Store the user input and then output it
            f = prompt
            # Store the fraction as a list to separate out the numeric elements
            f = f.split('/')
            # Store the numerator and denominator as x and y
            x = int(f[0])
            y = int(f[1])
            # Verify that Y > X
            if x > y:
                pass
            else:
                return round(x / y, 2)
        except ValueError:
            pass
        except ZeroDivisionError:
            pass

main()
```

```{python}
#| lst-label: lst-3_taqueria
#| lst-cap: Felipe's Taqueria
#| code-line-numbers: true
#| eval: false

# Build the main function
def main():
    # Define the food items
    menu = {
    "Baja Taco": 4.25,
    "Burrito": 7.50,
    "Bowl": 8.50,
    "Nachos": 11.00,
    "Quesadilla": 8.50,
    "Super Burrito": 8.50,
    "Super Quesadilla": 9.50,
    "Taco": 3.00,
    "Tortilla Salad": 8.00
    }
    # Create a loop to continuously prompt the users
    total_ord = 0

    #while True:
    try:
        # Prompt the user
        item_food = food("super quesadilla").title()
        # Reprompt the user if the food isn't on the menu
        if item_food in menu.keys():
            # Return the total
            total_ord = round(total_ord + menu.get(item_food), 2)
            print(f"Total: ${total_ord:.2f}")
        else:
            return
    except:
        return print("")

# Build the food input function
def food(prompt):
    f = str(prompt) 
    return f

main()

```

```{python}
#| lst-label: lst-3_grocery
#| lst-cap: Grocery List
#| code-line-numbers: true
#| eval: false

# Build the main function
# Try using enumerate or some other similar function to number the iterations of the food
def main():
    # Create an empty list for groceries
    item = []
    # Function to populate the list
    while True:
        try:
            item.append("milk".strip().upper())
        except EOFError:
            # Function to transform the list
            grocery_list = final(item)
            # Return the final list
            for k, v in grocery_list.items():
                print(f"{v} {k}")
            break

def final(item_list):
    # Initialize a blank dictionary to store counts
    output = {}
    # Sort the list alphabetically
    item_list = sorted(item_list)
    # Iterate through the list, store values and counts in the dictionary
    for i in item_list:
        if i in output:
            output[i] += 1
        else:
            output[i] = 1

    return output

main()
```

```{python}
#| lst-label: lst-3_outdated
#| lst-cap: Outdated
#| code-line-numbers: true
#| eval: false

# Build the main function
def main():
    global months
    # List containing the months in Titlecase
    months = {
        "January" : '1',
        "February" : '2',
        "March" : '3',
        "April" : '4',
        "May" : '5',
        "June" : '6',
        "July" : '7',
        "August" : '8',
        "September" : '9',
        "October" : '10',
        "November" : '11',
        "December" : '12'
    }

    # Initialize a blank list for the separated date string
    date_list = []
    # Prompt a user for the date, ensure the month and format are acceptable before continuing
    while True:
        try:
            ad = "January 7, 1998".strip().title()
            # See if there is a '/' in the date, then handle accordingly
            if '/' in ad:
                date_list = ad.split('/')
                if date_list[0] in months.values() and int(date_list[1]) <= 31:
                    break
                else:
                    pass # Reprompt the user for input if the month is incorrect
            # See if there is a ' ' in the date, then handle accordingly
            elif ' ' in ad:
                date_list = ad.split(' ')
                if ',' in date_list[1]:
                    date_list[1] = date_list[1].replace(',', '')
                    if date_list[0].title() in months.keys() and int(date_list[1]) <= 31:
                        break
                    else:
                        pass
                else:
                    pass # Reprompt if there is no comma, you can also use continue
            else:
                pass
        except:
            pass # If the code encounters an error, reprompt the user

    # Convert the format from middle-endian to big-endian
    date_fin = big_end(date_list)

    # Pad the month and day with leading zeros if necessary
    date_fin[1] = date_fin[1].zfill(2)
    date_fin[2] = date_fin[2].zfill(2)

    return print(f"{date_fin[0]}-{date_fin[1]}-{date_fin[2]}")

# Define the endian conversion function
def big_end(m_end):
    # Check whether it's a numeric or string formatted month
    if m_end[0] in months.keys():
        m_end[0] = months.get(m_end[0])
        b_end = [m_end[2], m_end[0], m_end[1]]
        return b_end
    elif m_end[0] in months.values():
        b_end = [m_end[2], m_end[0], m_end[1]]
        return b_end
    else:
        return 0

main()
```

# Unit 4: Libraries {#sec-unit_4}
## Lecture 4 {#sec-lecture_4}
- Generally, libraries are bits of code written by your or others that you can use in your program
- Python allows you to share functions or features with others as `modules`
- If you ever copy/paste code from a previous script to a new one, or do repetitive work, you can create a library module

### Random {#sec-random}
- `random` is a library that comes with base Python, which you can import into your own project
  - It's more efficient to use existing code (created by you or others) when possible
- To load the module into your script, use the word `import`
  - It's the common/best practice to import all required modules at the top of a program
  - In this case, simply enter `import random` to make the library accessible within the scope of the program
  - If you only want a specific function(s) from a module, modify your syntax as follows `from random import choice`
- This library comes loaded with numerous features for programmatic randomization, read more in the [random]<https://docs.python.org/3/library/random.html> documentation

### Statistics {#sec-statistics}
- `statistics` is a library that comes with base Python
- It has useful functions that simplify the coding of basic statistical methods
  - `mean()`
  - `median()`
  - `mode()`
  - `quantiile()`
  - etc.
- Read more in the [statistics]<https://docs.python.org/3/library/statistics.html> documentation
  
### Command Line Arguments {#sec-command_line_arguments}
- So far, all of the values are provided within the program, but, similarly to bash, you can pass arguments directly from your CLI to a Python program
- `sys` is the base Python library for interacting with the command line and local file system
- Within that module, the `argv` function allows your program to take in additional arguments entered in the CLI
  - For example, you have a Python program `print("My name is", sys.argv[1]")` called `hi.py`
  - If you are in the project directory and run `python hi.py Chris` the CLI would output `My name is Chris`
  - Ensure proper error handling, in case too few arguments are included
```{python}
#| eval: false

import sys

try:
    print("My name is", sys.argv[1])
except IndexError:
    print("Too few arguments")
```
:::{#nte-argv_index .callout-note}
#### The argv index
The reason `sys.argv[1]` is used to capture the first CLI argument is that the 0th position is taken by `hi.py`, in this example.
:::
- While providing a useful message for what caused the error is a good first step, you can further improve upon the code
- If you add conditionals, you could ensure the number of arguments is 2 (one for the program, one for the name) and provide debugging assistance
  - `if len(sys.argv) < 2`
  - `elif len(sys.argv) > 2`
- The code is logically correct, but it's nice to separate out error handling
```{python}
#| eval: false

import sys

if len(sys.argv) < 2:
    sys.exit("Too few arguments")
elif len(sys.argv) > 2:
    sys.exit("Too many arguments")

print("hello, my name is", sys.argv[1])
```

### slice {#sec-slice}
- `slice` is a command that allows you to take a `list` and tell the compiler where to consider the start and end of it
- Simply put, you could modify your previous code to use `slice` as follows
```{python}
#| eval: false

import sys

if len(sys.argv) < 2:
    sys.exit("Too few arguments")

for arg in sys.argv[1:]:
    print("hello, my name is", arg)

```

- Notice that rather than starting the list at 0, we use square brackets to tell the compiler to start at 1 and go to the end using the 1: argument. Running this code, you’ll notice that we can improve our code using relatively simple syntax.

### Packages {#sec-packages}
- One of the reasons Python is popular are the numerous third-party libraries that add functionality
  - In Python these, libraries implemented as folders, are called packages
- `PyPI` is a repository or directory of all third-party packages currently available
- `cowsay` is a well-known package that allows a cow to talk to the user
- The Python package manager is called `pip` and it easily allows you to download packages to your local system
  - If you want to install a package locally, so you can import it into scripts, `pip install cowsay`
:::{#imp-virtual_environments .callout-important}
#### Virtual Environments and Isolation
It's common practice in Python (and other languages) to create virtual environments or containers (when a more robust solution is needed), to isolate program requirements to specific projects. Typically, you won't need much more than pip and/or wheel (a package to handle C dependencies) installed locally. Then, use `pip install` within that `venv`. If you use `pip freeze > requirements.txt` within the venv, you can save the installed dependencies to a local file and then install those in new environments more easily. View the official [venv]<https://docs.python.org/3/library/venv.html> documentation to learn more.
:::

### APIs {#sec-apis}
- Application program interfaces, or `API`, allow you to connect to the code of others
- Basic Python has the `requests` package which allows your program to behave as a web browser would
  - This is commonly used to scrape websites for data or automatically retrieve new information
  - Common formats for data downloaded off the internet are `.csv`, `.txt`, and `.json`
  - Read more in the offciail [requests]<https://docs.python-requests.org/> documentation
- The `.json` file format stands for `JavaScriptObjectNotation` and is a ***structured*** format for storing data
  - *Structured* implies a `key:value` storage format, the same as dictionaries
  - Luckily, python has the `json` library that can help interpret and manipulate json data
  - Read more in the official [json]<https://docs.python.org/3/library/json.html> documentation

### Making Your Own Libraries {#sec-myo_libraries}
- Stated at the beginning of this unit, situations where you want to reuse bits of code or share it, are perfect for libraries
- For a basic example, take the following two code blocks
  - Assume the first block is a file called `sayings.py`
  - Assume the second is a separate .py file in the same local directory
  - Notice how the import syntax is the same, and only the functionality of `goodbye` is imported
```{python}
#| eval: false

def hello(name):
    print(f"hello, {name}")


def goodbye(name):
    print(f"goodbye, {name}")
```
```{python}
#| eval: false

import sys

from sayings import goodbye

if len(sys.argv) == 2:
    goodbye(sys.argv[1])
```

## Problem Set 4 {#sec-problem_set_4}
```{python}
#| lst-label: lst-emojize
#| lst-cap: Emojize
#| code-line-numbers: true
#| eval: false

# Ingest the required packages
import emoji # You will need to install this as it is not a base Python package

# Build the main function
def main():
    # Prompt the user for text
    prompt = input("Input: ")
    # Transform the str into an emoji
    output = emoji.emojize(prompt, language="alias")
    # Print the output
    print(output)

main()
```

```{python}
#| lst-label: lst-figlet
#| lst-cap: Frank, Ian, and Glen's Letters
#| code-line-numbers: true
#| eval: false

# Import the required packages
import sys
import random
from pyfiglet import Figlet

# Build the main function
def main():
    # Initialize Figlet
    figlet = Figlet()
    # Get the available fonts
    fonts = figlet.getFonts()
    # Check that there are 0 or 2 arguments
    if len(sys.argv) == 1 or len(sys.argv) == 3:
        # If there are 0 arguments, randomly select a font
        if len(sys.argv) == 1:
            figlet.setFont(font=random.choice(fonts))
        # If there are 2 arguments, select the specified font
        elif len(sys.argv) == 3:
            if sys.argv[1] == "-f" or sys.argv[1] == "--font":
                if sys.argv[2] in fonts:
                    figlet.setFont(font=sys.argv[2])
                else:
                    sys.exit("Invalid usage")
            else:
                sys.exit("Invalid usage")
        # Prompt the user for input and render the text
        base = input("Input: ")
        print(figlet.renderText(base))
    elif len(sys.argv) == 2 or 3 < len(sys.argv):
        sys.exit("Invalid usage")
    else:
        sys.exit("Invalid usage")

main()
```

```{python}
#| lst-label: lst-adieu
#| lst-cap: Adieu, Adieu
#| code-line-numbers: true
#| eval: false

# Import the required packages
import inflect

# Build the main function
def main():
    p = inflect.engine()
    name = []
    while True:
        try:
            name.append(input("Name: "))
        except EOFError:
            hills = p.join(name, final_sep=",")
            return print("Adieu, adieu, to", hills)

main()
```

```{python}
#| lst-label: lst-game
#| lst-cap: Guessing Game
#| code-line-numbers: true
#| eval: false

# Import the necessary packages
import random
import sys

# Build the main function
def main():
    # Initialize the random seed
    #random.seed(a=12345)
    # Prompt the user for a positive integer
    while True:
        try:
            n = int(input("Level: "))
            if 0 < n:
                break
        except ValueError:
            pass

    # Generate a random number
    num = random.randint(1, n)
    # Reprompt the user for a guess until they get it correct
    while True:
        try:
            guess = int(input("Guess: "))
            if guess < num:
                print("Too small!")
            elif num < guess:
                print("Too large!")
            else:
                sys.exit("Just right!")
        except ValueError:
            pass


main()
```

```{python}
#| lst-label: lst-professor
#| lst-cap: Little Professor
#| code-line-numbers: true
#| eval: false

# Import the necessary packages
import random

# Build the main function
def main():
    # Prompt the user for a level, n of value 1, 2, or 3
    level = get_level()

    # Initialize the score
    score = 0

    # Generate the equations
    for _ in range(10):
        x = generate_integer(level)
        y = generate_integer(level)

        # Allow the user up to three attempts per equation
        attempt = 0
        while attempt < 3:
            try:
                # Prompt the user for the answer
                a = int(input(f"{x} + {y} = "))

                # Check the answer
                if a == (x + y):
                    score += 1
                    break
                else:
                    print("EEE")
                    attempt += 1
            # If the input isn't an integer
            except ValueError:
                print("EEE")
                attempt += 1

        # If the user fails after 3 attempts, show the correct answer
        if attempt == 3:
            print(f"{x} + {y} = {x + y}")

    # Output the user's score
    print(f"Score: {score}")


def get_level():
    while True:
        try:
            level = int(input("Level: "))
            if level in [1, 2, 3]:
                return level
        except ValueError:
            pass


# Build the generate integer function
def generate_integer(level):
    # See which level and generate an X and Y value
    if level == 1:
        return random.randint(0, 9)
    elif level == 2:
        return random.randint(10, 99)
    elif level == 3:
        return random.randint(100, 999)
    else:
        raise ValueError("Level must be 1, 2, or 3")


if __name__ == '__main__':
    main()


```

:::{#nte-if_name_guard .callout-note}
#### The `if __name__ == '__main__'` technique
You may be wondering why you see this code syntax when calling main functions instead of just `main()` at the end of some scripts. When writing production code, you might need to import your script to run tests on individual functions (like get_level() or generate_integer()). If you don't include the `if __name__ == "__main__":` guard, `main()` will run immediately when the script is imported, causing unintended behavior during testing.
:::

```{python}
#| lst-label: lst-bitcoin
#| lst-cap: Bitcoin Price Index
#| code-line-numbers: true
#| eval: false



```

# Unit 5: Unit Tests {#sec-unit_5}
## Lecture 5 {#sec-lecture_5}

## Problem Set 5 {#sec-problem_set_5}
```{python}
#| lst-label: lst-test_twttr
#| lst-cap: Testing my twttr
#| code-line-numbers: true
#| eval: false



```

```{python}
#| lst-label: lst-test_bank
#| lst-cap: Back to the Bank
#| code-line-numbers: true
#| eval: false



```

```{python}
#| lst-label: lst-test_plates
#| lst-cap: Re-requesting a Vanity Plate
#| code-line-numbers: true
#| eval: false



```

```{python}
#| lst-label: lst-test_fuel
#| lst-cap: Refueling
#| code-line-numbers: true
#| eval: false



```

# Unit 6: File I/O {#sec-unit_6}
## Lecture 6 {#sec-lecture_6}

## Problem Set 6 {#sec-problem_set_6}
```{python}
#| lst-label: lst-lines
#| lst-cap: Lines of Code
#| code-line-numbers: true
#| eval: false



```

```{python}
#| lst-label: lst-pizza
#| lst-cap: Pizza Py
#| code-line-numbers: true
#| eval: false



```

```{python}
#| lst-label: lst-scourgify
#| lst-cap: Scourgify
#| code-line-numbers: true
#| eval: false



```

```{python}
#| lst-label: lst-shirt
#| lst-cap: CS50 P-Shirt
#| code-line-numbers: true
#| eval: false



```

# Unit 7: Regular Expressions {#sec-unit_7}
## Lecture 7 {#sec-lecture_7}

## Problem Set 7 {#sec-problem_set_7}
```{python}
#| lst-label: lst-numb3rs
#| lst-cap: NUMB3RS
#| code-line-numbers: true
#| eval: false



```

```{python}
#| lst-label: lst-watch
#| lst-cap: Watch on YouTube
#| code-line-numbers: true
#| eval: false



```

```{python}
#| lst-label: lst-working
#| lst-cap: Working 9-to-5
#| code-line-numbers: true
#| eval: false



```
```{python}
#| lst-label: lst-um
#| lst-cap: Regular, um, Expressions
#| code-line-numbers: true
#| eval: false



```

```{python}
#| lst-label: lst-response
#| lst-cap: Response Validation
#| code-line-numbers: true
#| eval: false



```

# Unit 8: Object Oriented Programming {#sec-unit_8}
## Lecture 8 {#sec-lecture_8}

## Problem Set 8 {#sec-problem_set_8}
```{python}
#| lst-label: lst-seasons
#| lst-cap: Seasons of Love
#| code-line-numbers: true
#| eval: false



```

```{python}
#| lst-label: lst-jar
#| lst-cap: Cookie Jar
#| code-line-numbers: true
#| eval: false



```

```{python}
#| lst-label: lst-shirtificate
#| lst-cap: CS50 Shirtificate
#| code-line-numbers: true
#| eval: false



```